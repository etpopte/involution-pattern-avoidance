def involutionContains(sigma,pi):
    # checks whether pi (an involution) contains sigma (an involution) as an involution
    # this means viewing pi, sigma as (partial) matchings, we can delete some combinations of
    # fixed points, 2-cycles or one vertex of a nested 2-cycle from pi to produce sigma
    return sigma in subInvolutions([pi],len(sigma.to_cycles()))

def makeSubInvolutions(permList, goalCycles, numCycles):
    #Given a list of involutions permList and a integer goalCycles, finds the list of sub-involutions
    #with goalCycles number of cycles. First we will attempt to merge as many times as possible every
    #permutation on the list. Then if the number of cycles is greater than the desired number of cycles,
    #we will attempt to delete a cycle from each permutation in every way possible.
    listLen = len(permList)
    numNewPerms = 0
    for i in range(listLen):
        newPerms = subInvolutionsMerge(permList[i])
        numNewPerms += len(newPerms)
        permList += newPerms
    while numNewPerms != 0:
        listEnd = listLen + numNewPerms
        numNewPerms = 0
        for i in range(listLen, listEnd):
            newPerms = subInvolutionsMerge(permList[i])
            numNewPerms += len(newPerms)
            permList += newPerms
        listLen = listEnd
    permList = list(set(permList))
    if numCycles > goalCycles:
        subPermList = []
        for i in range(len(permList)):
            subPermList += subInvolutionsCycle(permList[i])
        subPermList = list(set(subPermList))
        return subPermList
    return permList

def subInvolutions(permList, goalCycles):
    ##Helper method for subInvolutions
    numCycles = len(permList[0].to_cycles())
    while(numCycles >= goalCycles):
        permList = makeSubInvolutions(permList, goalCycles, numCycles)
        numCycles -= 1
    return permList

def subInvolutionsCycle(sigma):
    #Given a permutation, we delete a cycle from the permutation in every possible way and
    #return the possibilities as a list of permutations.
    cycles = sigma.to_cycles()
    subPerms = []
    for c in cycles:
        sigma_copy = list(sigma)
        if sigma(c[0]) == c[0]:
            sigma_copy.pop(c[0]-1)
        else:
            sigma_copy.pop(c[1]-1)
            sigma_copy.pop(c[0]-1)
        subPerms.append(Permutation(flatten(sigma_copy)))
    return subPerms

def subInvolutionsMerge(sigma):
    #Given a permutation, we merge a cycle with adjacent elements in every possible way and
    #return the possibilities as a list of permutation.
    cycles = sigma.to_cycles()
    subPerms = []
    for c in cycles:
        sigma_copy = list(sigma)
        if sigma(c[0]) != c[0]:
            if abs(c[0]-c[1])==1:
                sigma_copy.pop(c[0]-1)
                subPerms.append(Permutation(flatten(sigma_copy)))
    return subPerms

def flatten(word):
    # converts the list 'word' with distinct entries into a permutation with same relative order
    newWord = copy(word)
    newWord.sort()
    return Permutation([word.index(i)+1 for i in newWord]).inverse()

def iBasisFromPBasis(permBasis):
    #Given a list of permutations permBasis, determines the basis of the involution class defined by the
    #set of involutions in the permutation class generated by permBasis. Returns a set of involutions of
    #size less than 2k, where k is the size of the largest permutation in permBasis.
    involutions = []
    maxPerm = -1
    for i in range(len(permBasis)):
        maxPerm = max(permBasis[i].size(), maxPerm)
    for i in range(1, 2*maxPerm + 1):
        for sigma in Permutations(i):
            if(sigma == sigma.inverse()):
                flag = True
                for i in range(len(permBasis)):
                    flag = sigma.avoids(permBasis[i])
                    if(not flag):
                        break;
                if(not flag):
                    involutions.append(sigma)
    return reduceIBasis(involutions)

def reduceIBasis(invBasis):
    #Given a basis for an involution class invBasis, removes the unnecessary permutations and returns the minimal list
    newList = []
    for iota in invBasis:
        flag = True
        for kappa in invBasis:
            if(kappa.size() < iota.size() and involutionContains(kappa, iota)):
                flag = False
                break
        if(flag):
            newList.append(iota)
    return newList

def reducePBasis(permBasis):
    #Given a basis for a permutation class permBasis, removes the unnecessary permutations and returns the minimal list
    newList = []
    for sigma in permBasis:
        flag = True
        for tau in permBasis:
            if(tau.size() < sigma.size() and sigma.has_pattern(tau)):
                flag = False
                break
        if(flag):
            newList.append(sigma)
    return newList

def checkB(invSet):
    #Given a set of involutions invSet, checks the if basis for the permutation class
    #generated by invSet is equal to the basis for the involution class generated by permSet.
    invPBasis = iBasisFromPBasis(reducePBasis(invSet))
    invBasis = reduceIBasis(invSet)
    if len(invPBasis) == len(invBasis):
        return not sum([not sigma in invBasis for sigma in invPBasis])
    return False

def checkA(invSet):
    #Given a set of involutions invSet, checks if any of the involutions in invSet inv-contain 12.
    for sigma in invSet:
        if(involutionContains(Permutation([1,2]),sigma)):
            return False
    return True

def checkBimpliesA(invSet):
    #returns B implies A
    return checkA(invSet) or (not checkB(invSet))

def IClass(permBasis, size):
    #returns the elements of an involution class up to n equal to size
    IClass = []
    for i in range(1,size+1):
        IClass.append(IClassN(permBasis, i))
    return IClass

def IClassN(permBasis, n):
    IClassN = []
    for pi in Permutations(n):
        if pi.inverse() == pi:
            flag = False
            for sigma in permBasis:
                flag = involutionContains(sigma, pi)
                if(flag):
                    break
            if(not flag):
                IClassN.append(pi)
    return IClassN

def IClassSize(permBasis, n):
    return len(IClassN(permBasis, n))
